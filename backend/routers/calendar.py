"""
routers/calendar.py
====================
GET  /calendar/team.ics   — merged team calendar download
POST /calendar/upload     — upload one or more .ics files (or a .zip) and
                            sync each matched member's availability to the DB

Merges every team member's ICS file into a single VCALENDAR and returns it
with Content-Type: text/calendar so browsers / calendar apps can subscribe to
or download it directly.

ICS resolution order per member:
  1. backend/ics/<member_id>.ics   (generated by generate_team_ics.py)
  2. backend/<member.ics_path>     (real ICS path stored in DB, e.g. dummy_maya_calendar.ics)
  3. Skip silently if neither exists.

Each VEVENT SUMMARY is prefixed with "[FirstName] " for easy identification.
"""

from __future__ import annotations

import io
import zipfile
from pathlib import Path

import icalendar
from fastapi import APIRouter, File, UploadFile
from fastapi.responses import Response
from sqlmodel import Session, select

from calendar_availability import get_availability_report
from crud import update_member_calendar_pct, update_member_week_availability
from database import engine
from models import TeamMember

router = APIRouter()

BACKEND_DIR = Path(__file__).parent.parent
ICS_DIR = BACKEND_DIR / "ics"

# Member IDs that have a real ICS file in the DB ics_path field
REAL_ICS_MEMBERS: set[str] = {"mem-012"}


def _resolve_ics_path(member: TeamMember) -> Path | None:
    """Return the best ICS path for a member, or None if not found."""
    # Prefer the generated per-member file
    generated = ICS_DIR / f"{member.id}.ics"
    if generated.exists():
        return generated

    # Fall back to the DB-stored path (relative to backend/)
    if member.ics_path:
        real = BACKEND_DIR / member.ics_path
        if real.exists():
            return real

    return None


def _first_name(name: str) -> str:
    return name.split()[0]


def _merge_calendars(members: list[TeamMember]) -> bytes:
    merged = icalendar.Calendar()
    merged.add("VERSION", "2.0")
    merged.add("PRODID", "-//Vantage//Team Calendar//EN")
    merged.add("X-WR-CALNAME", "Vantage Team Calendar")
    merged.add("CALSCALE", "GREGORIAN")
    merged.add("METHOD", "PUBLISH")

    for member in members:
        path = _resolve_ics_path(member)
        if path is None:
            continue

        try:
            cal = icalendar.Calendar.from_ical(path.read_bytes())
        except Exception:
            continue

        prefix = f"[{_first_name(member.name)}] "
        for component in cal.walk():
            if component.name != "VEVENT":
                continue

            # Clone by rebuilding from the ical string (safest deep-copy approach)
            cloned = icalendar.Event.from_ical(component.to_ical())
            event = icalendar.Event()
            for key, val in cloned.items():
                event.add(key, val)

            # Prefix the summary
            summary = str(event.get("SUMMARY", ""))
            if not summary.startswith(prefix):
                event["SUMMARY"] = icalendar.vText(prefix + summary)

            merged.add_component(event)

    return merged.to_ical()


@router.get("/calendar/team.ics", include_in_schema=True)
def team_calendar():
    """Download a merged ICS file with all team members' schedules."""
    with Session(engine) as db:
        members = db.exec(select(TeamMember)).all()

    ics_bytes = _merge_calendars(list(members))

    return Response(
        content=ics_bytes,
        media_type="text/calendar",
        headers={
            "Content-Disposition": 'attachment; filename="vantage-team.ics"',
            "Cache-Control": "no-cache",
        },
    )


# ── Helpers ─────────────────────────────────────────────────────────────────────

_DAY_MAP = {
    "Monday": "monday", "Tuesday": "tuesday", "Wednesday": "wednesday",
    "Thursday": "thursday", "Friday": "friday",
}


def _collect_ics_entries(upload: UploadFile, raw: bytes) -> list[tuple[str, bytes]]:
    """Return a list of (filename, ics_bytes) from a single UploadFile.

    If the file is a ZIP archive every .ics member inside it is extracted.
    Otherwise the file itself is returned as-is.
    """
    name = (upload.filename or "").lower()
    if name.endswith(".zip") or upload.content_type in (
        "application/zip", "application/x-zip-compressed"
    ):
        entries: list[tuple[str, bytes]] = []
        try:
            with zipfile.ZipFile(io.BytesIO(raw)) as zf:
                for info in zf.infolist():
                    if info.filename.lower().endswith(".ics") and not info.is_dir():
                        entries.append((Path(info.filename).name, zf.read(info.filename)))
        except zipfile.BadZipFile:
            pass
        return entries
    return [(upload.filename or "upload.ics", raw)]


def _match_member(filename: str, ics_bytes: bytes, members: list[TeamMember]) -> TeamMember | None:
    """Try to find the TeamMember that owns this ICS file.

    Strategy 1 — filename: strip the .ics suffix and compare to member IDs.
    Strategy 2 — X-WR-CALNAME: parse the ICS and fuzzy-match the calendar
                 name against member names (case-insensitive substring).
    """
    stem = Path(filename).stem  # e.g. "mem-001" from "mem-001.ics"
    for m in members:
        if m.id == stem:
            return m

    # Fallback: check X-WR-CALNAME
    try:
        cal = icalendar.Calendar.from_ical(ics_bytes)
        cal_name = str(cal.get("X-WR-CALNAME", "")).lower()
        if cal_name:
            for m in members:
                if m.name.lower() in cal_name or cal_name in m.name.lower():
                    return m
    except Exception:
        pass

    return None


# ── Upload endpoint ──────────────────────────────────────────────────────────────

@router.post("/calendar/upload")
async def upload_calendars(files: list[UploadFile] = File(...)):
    """Upload one or more .ics files (or a .zip archive containing them).

    Each file is matched to a team member by filename (e.g. mem-001.ics) or
    by the X-WR-CALNAME property.  Matched files are saved to backend/ics/,
    linked in the DB, and the member's availability is recalculated.
    """
    ICS_DIR.mkdir(exist_ok=True)

    with Session(engine) as db:
        members = list(db.exec(select(TeamMember)).all())

    processed: list[dict] = []
    unmatched: list[str] = []

    for upload in files:
        raw = await upload.read()
        entries = _collect_ics_entries(upload, raw)

        for filename, ics_bytes in entries:
            member = _match_member(filename, ics_bytes, members)
            if member is None:
                unmatched.append(filename)
                continue

            # Save ICS file
            out_path = ICS_DIR / f"{member.id}.ics"
            out_path.write_bytes(ics_bytes)
            rel_path = f"ics/{member.id}.ics"

            # Run availability pipeline
            try:
                report = get_availability_report(ics_path=out_path, timezone="UTC")
            except Exception as exc:
                processed.append({
                    "memberId": member.id,
                    "memberName": member.name,
                    "status": "error",
                    "detail": str(exc),
                })
                continue

            per_day = {
                _DAY_MAP[d["weekday"]]: round(d["availability_pct"])
                for d in report["per_day"]
                if d["weekday"] in _DAY_MAP
            }

            # Persist to DB
            with Session(engine) as db:
                row = db.get(TeamMember, member.id)
                if row:
                    row.ics_path = rel_path
                    db.add(row)
                    db.commit()
                update_member_calendar_pct(db, member.id, report["availability_pct"])
                update_member_week_availability(db, member.id, per_day)

            processed.append({
                "memberId": member.id,
                "memberName": member.name,
                "calendarPct": round(report["availability_pct"], 1),
                "status": "ok",
            })

    return {"processed": processed, "unmatched": unmatched}
